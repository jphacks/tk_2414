// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package courses

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const courseNameByID = `-- name: CourseNameByID :one
SELECT name
FROM courses
WHERE id = $1
  AND deleted_at IS NULL
`

func (q *Queries) CourseNameByID(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRowContext(ctx, courseNameByID, id)
	var name string
	err := row.Scan(&name)
	return name, err
}

const deleteLecture = `-- name: DeleteLecture :exec
UPDATE lectures
SET deleted_at = now()
WHERE id = $1
`

func (q *Queries) DeleteLecture(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteLecture, id)
	return err
}

const getCountLecturesByCourseIDs = `-- name: GetCountLecturesByCourseIDs :many
SELECT course_id, COUNT(DISTINCT id)
FROM lectures
WHERE course_id = ANY($1::TEXT[])
GROUP BY course_id
ORDER BY created_at ASC
`

type GetCountLecturesByCourseIDsRow struct {
	CourseID string
	Count    int64
}

func (q *Queries) GetCountLecturesByCourseIDs(ctx context.Context, dollar_1 []string) ([]GetCountLecturesByCourseIDsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCountLecturesByCourseIDs, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCountLecturesByCourseIDsRow
	for rows.Next() {
		var i GetCountLecturesByCourseIDsRow
		if err := rows.Scan(&i.CourseID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountLecturesByUser = `-- name: GetCountLecturesByUser :many
SELECT course_id, COUNT(id)
FROM lectures
WHERE id = ANY($1::TEXT[])
GROUP BY course_id
ORDER BY created_at ASC
`

type GetCountLecturesByUserRow struct {
	CourseID string
	Count    int64
}

func (q *Queries) GetCountLecturesByUser(ctx context.Context, dollar_1 []string) ([]GetCountLecturesByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getCountLecturesByUser, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCountLecturesByUserRow
	for rows.Next() {
		var i GetCountLecturesByUserRow
		if err := rows.Scan(&i.CourseID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCourseIDByLectureID = `-- name: GetCourseIDByLectureID :one
SELECT course_id
FROM lectures
WHERE id = $1
  AND deleted_at IS NULL
`

func (q *Queries) GetCourseIDByLectureID(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRowContext(ctx, getCourseIDByLectureID, id)
	var course_id string
	err := row.Scan(&course_id)
	return course_id, err
}

const getCourseIDsByLectureIDs = `-- name: GetCourseIDsByLectureIDs :many
SELECT DISTINCT course_id
FROM lectures
WHERE id = ANY($1::TEXT[])
`

func (q *Queries) GetCourseIDsByLectureIDs(ctx context.Context, dollar_1 []string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getCourseIDsByLectureIDs, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var course_id string
		if err := rows.Scan(&course_id); err != nil {
			return nil, err
		}
		items = append(items, course_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCourseNamesByCourseIDs = `-- name: GetCourseNamesByCourseIDs :many
SELECT name
FROM courses
WHERE id = ANY($1::TEXT[])
`

func (q *Queries) GetCourseNamesByCourseIDs(ctx context.Context, dollar_1 []string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getCourseNamesByCourseIDs, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLectureNameByID = `-- name: GetLectureNameByID :one
SELECT name
FROM lectures
WHERE id = $1
  AND deleted_at IS NULL
`

func (q *Queries) GetLectureNameByID(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRowContext(ctx, getLectureNameByID, id)
	var name string
	err := row.Scan(&name)
	return name, err
}

const getLectureNamesByLectureIDs = `-- name: GetLectureNamesByLectureIDs :many
SELECT id, name
FROM courses
WHERE id = ANY($1::TEXT[])
`

type GetLectureNamesByLectureIDsRow struct {
	ID   string
	Name string
}

func (q *Queries) GetLectureNamesByLectureIDs(ctx context.Context, dollar_1 []string) ([]GetLectureNamesByLectureIDsRow, error) {
	rows, err := q.db.QueryContext(ctx, getLectureNamesByLectureIDs, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLectureNamesByLectureIDsRow
	for rows.Next() {
		var i GetLectureNamesByLectureIDsRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderedLecturesByCourseID = `-- name: GetOrderedLecturesByCourseID :many
WITH RECURSIVE ordered_lectures AS (
    SELECT l.id, l.course_id, l.name, l.description, l.prev, l.next, 1 as position
    FROM lectures l
    WHERE l.course_id = $1
      AND l.prev IS NULL
      AND l.deleted_at IS NULL
    UNION ALL
    SELECT l.id, l.course_id, l.name, l.description, l.prev, l.next, ol.position + 1
    FROM lectures l
    INNER JOIN ordered_lectures ol ON l.prev = ol.id
    WHERE l.course_id = $1
      AND l.deleted_at IS NULL
)
SELECT id, course_id, name, description, position
FROM ordered_lectures
ORDER BY position
`

type GetOrderedLecturesByCourseIDRow struct {
	ID          string
	CourseID    string
	Name        string
	Description string
	Position    int32
}

func (q *Queries) GetOrderedLecturesByCourseID(ctx context.Context, courseID string) ([]GetOrderedLecturesByCourseIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrderedLecturesByCourseID, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderedLecturesByCourseIDRow
	for rows.Next() {
		var i GetOrderedLecturesByCourseIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CourseID,
			&i.Name,
			&i.Description,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertUserProgress = `-- name: InsertUserProgress :one
INSERT INTO user_progresses (id, lecture_id, user_id)
VALUES ($1, $2, $3)
RETURNING id, lecture_id, user_id, created_at, updated_at
`

type InsertUserProgressParams struct {
	ID        string
	LectureID string
	UserID    string
}

type InsertUserProgressRow struct {
	ID        string
	LectureID string
	UserID    string
	CreatedAt sql.NullTime
	UpdatedAt sql.NullTime
}

func (q *Queries) InsertUserProgress(ctx context.Context, arg InsertUserProgressParams) (InsertUserProgressRow, error) {
	row := q.db.QueryRowContext(ctx, insertUserProgress, arg.ID, arg.LectureID, arg.UserID)
	var i InsertUserProgressRow
	err := row.Scan(
		&i.ID,
		&i.LectureID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const selectAllUserProgressByUserID = `-- name: SelectAllUserProgressByUserID :many
SELECT id, user_id, lecture_id
FROM user_progresses
WHERE user_id = $1
`

type SelectAllUserProgressByUserIDRow struct {
	ID        string
	UserID    string
	LectureID string
}

func (q *Queries) SelectAllUserProgressByUserID(ctx context.Context, userID string) ([]SelectAllUserProgressByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, selectAllUserProgressByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectAllUserProgressByUserIDRow
	for rows.Next() {
		var i SelectAllUserProgressByUserIDRow
		if err := rows.Scan(&i.ID, &i.UserID, &i.LectureID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectCourseByID = `-- name: SelectCourseByID :one
SELECT id, name, description, grade_id, subject, level
FROM courses
WHERE id = $1
  AND deleted_at IS NULL
`

type SelectCourseByIDRow struct {
	ID          string
	Name        string
	Description string
	GradeID     string
	Subject     string
	Level       string
}

func (q *Queries) SelectCourseByID(ctx context.Context, id string) (SelectCourseByIDRow, error) {
	row := q.db.QueryRowContext(ctx, selectCourseByID, id)
	var i SelectCourseByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.GradeID,
		&i.Subject,
		&i.Level,
	)
	return i, err
}

const selectCourses = `-- name: SelectCourses :many
SELECT id, name, description, grade_id, subject, level
FROM courses
WHERE deleted_at IS NULL
`

type SelectCoursesRow struct {
	ID          string
	Name        string
	Description string
	GradeID     string
	Subject     string
	Level       string
}

func (q *Queries) SelectCourses(ctx context.Context) ([]SelectCoursesRow, error) {
	rows, err := q.db.QueryContext(ctx, selectCourses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectCoursesRow
	for rows.Next() {
		var i SelectCoursesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.GradeID,
			&i.Subject,
			&i.Level,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectFinishedCoursesByUserID = `-- name: SelectFinishedCoursesByUserID :many
SELECT c.id AS course_id, c.name, c.description, c.grade_id, c.subject, c.level
FROM courses c
JOIN lectures l ON l.course_id = c.id
JOIN user_progresses up ON up.lecture_id = l.id
WHERE up.user_id = $1
  AND l.deleted_at IS NULL
  AND c.deleted_at IS NULL
  AND NOT EXISTS (
      SELECT 1 FROM lectures l2
      WHERE l2.course_id = c.id
        AND l2.deleted_at IS NULL
        AND EXISTS (
            SELECT 1 FROM user_progresses up2
            WHERE up2.lecture_id = l2.id
              AND up2.user_id = $1
        )
  )
GROUP BY c.id, c.name, c.description, c.grade_id, c.subject, c.level
`

type SelectFinishedCoursesByUserIDRow struct {
	CourseID    string
	Name        string
	Description string
	GradeID     string
	Subject     string
	Level       string
}

func (q *Queries) SelectFinishedCoursesByUserID(ctx context.Context, userID string) ([]SelectFinishedCoursesByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, selectFinishedCoursesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectFinishedCoursesByUserIDRow
	for rows.Next() {
		var i SelectFinishedCoursesByUserIDRow
		if err := rows.Scan(
			&i.CourseID,
			&i.Name,
			&i.Description,
			&i.GradeID,
			&i.Subject,
			&i.Level,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectLectureByID = `-- name: SelectLectureByID :one
SELECT id, course_id, name, description, prev, next, created_at
FROM lectures
WHERE id = $1
  AND deleted_at IS NULL
`

type SelectLectureByIDRow struct {
	ID          string
	CourseID    string
	Name        string
	Description string
	Prev        string
	Next        string
	CreatedAt   sql.NullTime
}

func (q *Queries) SelectLectureByID(ctx context.Context, id string) (SelectLectureByIDRow, error) {
	row := q.db.QueryRowContext(ctx, selectLectureByID, id)
	var i SelectLectureByIDRow
	err := row.Scan(
		&i.ID,
		&i.CourseID,
		&i.Name,
		&i.Description,
		&i.Prev,
		&i.Next,
		&i.CreatedAt,
	)
	return i, err
}

const selectLecturesByCourseID = `-- name: SelectLecturesByCourseID :many
SELECT id, name, description, prev, next
FROM lectures
WHERE course_id = $1
  AND deleted_at IS NULL
`

type SelectLecturesByCourseIDRow struct {
	ID          string
	Name        string
	Description string
	Prev        string
	Next        string
}

func (q *Queries) SelectLecturesByCourseID(ctx context.Context, courseID string) ([]SelectLecturesByCourseIDRow, error) {
	rows, err := q.db.QueryContext(ctx, selectLecturesByCourseID, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectLecturesByCourseIDRow
	for rows.Next() {
		var i SelectLecturesByCourseIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Prev,
			&i.Next,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectLecturesNotInProgress = `-- name: SelectLecturesNotInProgress :many
SELECT id
FROM lectures
WHERE course_id = $1
  AND deleted_at IS NULL
  AND NOT EXISTS (
    SELECT 1 FROM user_progresses
    WHERE lecture_id = lectures.id
      AND user_id = $2
  )
`

type SelectLecturesNotInProgressParams struct {
	CourseID string
	UserID   string
}

func (q *Queries) SelectLecturesNotInProgress(ctx context.Context, arg SelectLecturesNotInProgressParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectLecturesNotInProgress, arg.CourseID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectOngoingProgressByUserID = `-- name: SelectOngoingProgressByUserID :many
SELECT lecture_id
FROM user_progresses
WHERE user_id = $1
  AND deleted_at IS NULL
`

func (q *Queries) SelectOngoingProgressByUserID(ctx context.Context, userID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectOngoingProgressByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var lecture_id string
		if err := rows.Scan(&lecture_id); err != nil {
			return nil, err
		}
		items = append(items, lecture_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectTakingCoursesByUserID = `-- name: SelectTakingCoursesByUserID :many
SELECT c.id AS course_id, c.name, c.description, c.grade_id, c.subject, c.level
FROM courses c
JOIN lectures l ON l.course_id = c.id
JOIN user_progresses up ON up.lecture_id = l.id
WHERE up.user_id = $1
  AND l.deleted_at IS NULL
  AND c.deleted_at IS NULL
  AND NOT EXISTS (
      SELECT 1 FROM lectures l2
      WHERE l2.course_id = c.id
        AND l2.deleted_at IS NULL
        AND NOT EXISTS (
            SELECT 1 FROM user_progresses up2
            WHERE up2.lecture_id = l2.id
              AND up2.user_id = $1
        )
  )
GROUP BY c.id, c.name, c.description, c.grade_id, c.subject, c.level
`

type SelectTakingCoursesByUserIDRow struct {
	CourseID    string
	Name        string
	Description string
	GradeID     string
	Subject     string
	Level       string
}

func (q *Queries) SelectTakingCoursesByUserID(ctx context.Context, userID string) ([]SelectTakingCoursesByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, selectTakingCoursesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectTakingCoursesByUserIDRow
	for rows.Next() {
		var i SelectTakingCoursesByUserIDRow
		if err := rows.Scan(
			&i.CourseID,
			&i.Name,
			&i.Description,
			&i.GradeID,
			&i.Subject,
			&i.Level,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectUserProgressByLectureID = `-- name: SelectUserProgressByLectureID :one
SELECT id, user_id, lecture_id
FROM user_progresses
WHERE lecture_id = $1
  AND user_id = $2
`

type SelectUserProgressByLectureIDParams struct {
	LectureID string
	UserID    string
}

type SelectUserProgressByLectureIDRow struct {
	ID        string
	UserID    string
	LectureID string
}

func (q *Queries) SelectUserProgressByLectureID(ctx context.Context, arg SelectUserProgressByLectureIDParams) (SelectUserProgressByLectureIDRow, error) {
	row := q.db.QueryRowContext(ctx, selectUserProgressByLectureID, arg.LectureID, arg.UserID)
	var i SelectUserProgressByLectureIDRow
	err := row.Scan(&i.ID, &i.UserID, &i.LectureID)
	return i, err
}

const selectUserProgressByUserIDAndMonth = `-- name: SelectUserProgressByUserIDAndMonth :many
SELECT 
  to_char(created_at, 'YYYY-MM-DD') AS date, 
  ARRAY_AGG(lecture_id) AS lecture_ids
FROM user_progresses
WHERE user_id = $1
  AND to_char(created_at, 'YYYY-MM') = $2
  AND deleted_at IS NULL
GROUP BY date
ORDER BY date
`

type SelectUserProgressByUserIDAndMonthParams struct {
	UserID    string
	CreatedAt sql.NullTime
}

type SelectUserProgressByUserIDAndMonthRow struct {
	Date       string
	LectureIds interface{}
}

func (q *Queries) SelectUserProgressByUserIDAndMonth(ctx context.Context, arg SelectUserProgressByUserIDAndMonthParams) ([]SelectUserProgressByUserIDAndMonthRow, error) {
	rows, err := q.db.QueryContext(ctx, selectUserProgressByUserIDAndMonth, arg.UserID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectUserProgressByUserIDAndMonthRow
	for rows.Next() {
		var i SelectUserProgressByUserIDAndMonthRow
		if err := rows.Scan(&i.Date, &i.LectureIds); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
